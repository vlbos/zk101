---
title: 7. 总结
---

# 总结
我们对我们学到的内容进行总结和一些解惑。

## 1. STARK中怎么实现的ZK?

目前来看，STARK的ZK部分来自概率和部分揭露。

还记得我们最后验证过程吗？主要分两个步骤验证：
1.  **通过约束多项式，验证值是否是满足我们程序的条件约束。** 在第四章中，我们学习了如何创建约束多项式。而这个约束多项式是公开的，并且不会暴露Trace多项式。但是会暴露部分Trace的值。
2.  **通过FRI协议，验证这个值的生成多项式的次数是否满足预期。** 在第六章中，我们学习了如何使用FRI协议来验证多项式的次数。一般来说，如果你想要只修改一个值，并且其他所有值和原来的是一摸一样，他必须是一个比原来多项式高很多degree的新多项式。

### Trace的暴露
实际上在第一步的时候，我们需要对约束多项式求值，因此我们需要往系统请求多个Trace，代入约束多项式。这里有两个值的注意点。
1. 因为需要验证约束多项式，所以无可避免的会暴露一些Trace，但是我们求值是在LDE后的域上的，所以并不会一定会暴露真正的Trace值。
2. 当我们将结果代入约束多项式的时候，只有真正能求出值，我们才认为值满足约束，这里其实是对值验证的关键步骤，满足约束，即认为满足程序计算。

### FRI的验证意义
FRI是为了防止Prover构建其他的多项式，用更复杂的多项式创造部分结果不符合约束的多项式，来达到欺骗系统的效果。

在多项式承诺的时候，Prover会提交组合多项式折叠最后的结果，然后Verifier会根据相同路径进行折叠，并且判断最后的结果是否相同。如果抽查验证的时候使用了其他高次多项式进行欺骗，那么结果一定不同。